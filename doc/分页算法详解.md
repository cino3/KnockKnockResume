# 简历分页算法详解

> 用通俗的语言解释简历自动分页是如何实现的

## 📚 目录

1. [核心问题](#核心问题)
2. [基本概念](#基本概念)
3. [算法流程](#算法流程)
4. [关键技术](#关键技术)
5. [参数说明](#参数说明)
6. [常见问题](#常见问题)

---

## 核心问题

**一句话概括：** 如何把一份可能很长的简历，智能地分配到多个A4页面，确保：
- ✅ 每页内容不溢出
- ✅ 第1页底部有合适的留白（目前设置为18px）
- ✅ 内容不会在尴尬的位置被切断
- ✅ 打印效果美观

---

## 基本概念

### 1️⃣ A4页面尺寸

```
A4纸张总高度：1123px (96 DPI)
├─ 上边距：36px
├─ 内容区：1047px (这是可用高度！)
└─ 下边距：40px
```

**关键数字：** `MAX_CONTENT_HEIGHT = 1047px`（这就是每页能放多少内容）

---

### 2️⃣ 什么是"留白"？

**留白 = 页面底部空白区域**

```
┌─────────────────────┐
│   简历标题           │
│   个人信息           │
│   工作经历...        │ ← 内容区域
│   项目经验...        │
│   (空白区域)         │ ← 这就是"留白"
└─────────────────────┘
```

**目标：** 第1页留白 = 18px ± 4px（范围：14-22px）

---

### 3️⃣ 什么是"safetyBuffer"？

**安全缓冲区**——一个虚拟的"额外高度"，用于提前触发分页。

**比喻：**
- 你在装箱子时，为了防止最后一本书塞进去后箱子爆开
- 你会提前测量："如果给箱子加2mm厚度，还能装下吗？"
- 这个"2mm"就是safetyBuffer

**作用：**
- `safetyBuffer = 0` → 尽量多装（可能导致内容过满）
- `safetyBuffer = 5` → 保守一点（留更多空间）

**算法会自动寻找最优的safetyBuffer值**（搜索范围：-50px 到 50px）

---

## 算法流程

### 🎯 整体架构

```
用户编辑简历
    ↓
触发分页计算
    ↓
┌─────────────────────────────────┐
│  三步走策略                      │
├─────────────────────────────────┤
│  1️⃣ 粗测：用 safetyBuffer=0     │
│     看看各页留白情况              │
│                                 │
│  2️⃣ 优化：黄金分割搜索           │
│     找最优 safetyBuffer          │
│                                 │
│  3️⃣ 精调：行高压缩               │
│     减少第2+页的大片留白          │
└─────────────────────────────────┘
    ↓
渲染到页面
```

---

### 📏 第1步：粗测（了解现状）

**目标：** 快速看看如果不管三七二十一塞内容，会发生什么？

```javascript
// 用 safetyBuffer = 0 粗测一次
const initialTest = calculateWithBuffer(sourceRoot, 0)
```

**比喻：** 先试装一下箱子，看看会空多少还是会爆多少

**输出示例：**
```
📊 初测结果 (safetyBuffer=0):
   第1页=4px, 第2页=563px
```

**解读：**
- 第1页底部只有4px留白 → **太满了！**
- 第2页有563px留白 → **太空了！**

---

### 🔍 第2步：黄金分割搜索（找最优解）

**问题：** safetyBuffer应该设置为多少才能让第1页留白接近18px？

**朴素方法（太慢）：**
```
尝试 safetyBuffer = -50, -49, -48... 直到50
总共101次尝试，太慢了！
```

**黄金分割搜索（聪明）：**
- 只需要 **15次尝试** 就能找到最优解
- 利用黄金比例 φ ≈ 1.618
- 每次排除约 38% 的搜索范围

**工作原理：**

```
初始搜索范围：[-50, 50]
              ↓
        ┌──────┴──────┐
       mid1    φ    mid2  (黄金分割点)
      (-7.7)        (7.7)
       ↓              ↓
    计算得分      计算得分
       ↓              ↓
    选更优的，丢弃差的
       ↓
缩小范围到：[-50, 7.7]
       ↓
    重复15次...
       ↓
得到最优解！
```

**打分机制：** 如何判断哪个safetyBuffer更好？

```javascript
function calculateScore(pageHeights) {
  let totalScore = 0

  for (每页 i) {
    const 留白 = MAX_CONTENT_HEIGHT - pageHeights[i]

    if (i === 0) {  // 第1页
      const 偏差 = Math.abs(留白 - 18)
      if (14 <= 留白 <= 22) {
        totalScore -= 50  // 奖励！在目标范围内
      } else {
        totalScore += 偏差 * 3  // 惩罚：偏离目标越远越差
      }
    } else {  // 第2页及以后
      totalScore += 留白  // 留白越小越好
    }
  }

  return totalScore  // 分数越小越好
}
```

**示例：**
```
方案A：第1页留白=16px, 第2页留白=100px
  → 得分 = -50 + 100 = 50分

方案B：第1页留白=10px, 第2页留白=100px
  → 得分 = (8×3) + 100 = 124分

✅ 方案A更优（分数更低）
```

---

### 🔧 第3步：行高压缩（减少大片留白）

**问题：** 第2页可能有300px以上的大片留白，太浪费了！

**解决方案：** 压缩行高，让内容更紧凑

```
原始行高：1.6 (默认)
压缩后：1.55, 1.5, 1.45...
最小底线：1.4 (保证可读性)
```

**触发条件：** 只有当第2页留白 > 300px 才压缩

**压缩方法：**
1. 每次减少 0.05
2. 实际测量能节省多少空间
3. 如果节省空间 < 目标的一半，放弃压缩
4. 否则应用新行高

---

## 关键技术

### 🎨 技术点1：DOM克隆与测量

**为什么需要克隆？**

分页算法需要**模拟尝试不同的分页方案**，但又不能影响页面实际显示。

**比喻：**
- 你在设计房间布局
- 你在纸上画很多种方案（克隆的DOM）
- 测量哪种方案最合适
- 最后才在真实的房间里摆放（渲染到页面）

**代码示例：**
```javascript
// 克隆原始节点
const clonedNode = originalNode.cloneNode(true)

// 测量高度
const height = clonedNode.offsetHeight

// 测完后丢弃（不显示）
```

---

### 🎯 技术点2：Margin折叠处理

**问题：** CSS有个特性叫"margin折叠"

```
元素A：margin-bottom: 20px
元素B：margin-top: 30px

实际间距：max(20, 30) = 30px  （不是50px！）
```

**如果不处理margin折叠：**
- 计算高度不准确
- 分页点判断错误

**解决方案：**
```javascript
function getOuterHeightWithCollapse(el, prevMarginBottom) {
  const marginTop = el的marginTop
  const marginBottom = el的marginBottom

  // 折叠：取最大值
  const collapsedMarginTop = Math.max(marginTop, prevMarginBottom)

  return {
    height: el.offsetHeight + collapsedMarginTop + marginBottom,
    marginBottom: marginBottom  // 传给下一个元素
  }
}
```

---

### ✂️ 技术点3：按行拆分（轻量级方案）

**问题：** 一个很长的段落，要么全部放第1页，要么全部放第2页

```
原始状态：
┌─────────────────┐
│ 很长很长的段落   │ ← 假设高度100px
│ (3行文本)       │
└─────────────────┘
   ↓ 第1页只剩30px
   ↓ 放不下！整段移到第2页
   ↓ 第1页浪费30px空间！
```

**解决方案：** 按视觉行拆分

```
使用Canvas测量文本宽度，检测换行点：

原始：<p>"很长很长的段落文本..."</p>
      ↓ Canvas逐字符测量
      ↓ 检测哪里会换行
拆分：
  <p>"很长很长的段落"</p>  ← 第1行
  <p>"文本..."</p>         ← 第2行
```

**判断是否需要拆分：**
- 文本长度 > 40字符 → 尝试拆分
- Canvas测量如果真的多行 → 拆分成多个`<p>`

**效果：**
```
拆分前：100px的整体（要么全放，要么全移）
拆分后：3个33px的行（可以放2行，移1行）
```

---

### 🔧 技术点4：Vue Scoped样式修复

**问题：** `cloneNode(true)` 会丢失Vue的scoped样式（data-v-xxx属性）

**症状：** 克隆后的元素没有正确的CSS样式

**解决方案：** 手动添加关键内联样式

```javascript
function applyFixStyles(node) {
  // 为所有元素添加样式
  node.querySelectorAll('*').forEach(el => {
    el.style.width = 'auto'
    el.style.maxWidth = '100%'
    el.style.wordWrap = 'break-word'
    el.style.overflowWrap = 'break-word'
    // ... 确保文本能正常换行
  })
}
```

---

## 参数说明

### 📊 可调整的关键参数

| 参数名 | 位置 | 默认值 | 作用 |
|-------|------|-------|------|
| `TARGET_MARGIN` | 第14行 | **18px** | 第1页目标留白 |
| `MARGIN_TOLERANCE` | 第15行 | **4px** | 留白容差范围（±4px） |
| `PAGE_PADDING_Y` | 第11行 | **76px** | 上下边距之和（36+40） |
| `OVERFLOW_THRESHOLD` | 第13行 | **2px** | 允许的溢出容差 |

### 🎛️ 调整建议

**如果你想让第1页留白更大：**
```typescript
const TARGET_MARGIN = 30  // 改为30px
```

**如果你想让容差更严格：**
```typescript
const MARGIN_TOLERANCE = 2  // 改为±2px（范围：16-20px）
```

**如果你想调整页面上边距：**
```scss
// 在 preview.scss 中
padding: 36px 47px 40px 47px;  // 上 右 下 左
//     ↑改为你想要的值
```

**同时修改JS计算：**
```typescript
const PAGE_PADDING_Y = 上边距 + 下边距
```

---

## 常见问题

### ❓ Q1：为什么第1页留白不是精确的18px？

**A：** 因为内容是以"元素"或"行"为单位分页的，无法精确到像素级。

```
可能的留白值：4px, 22px, 35px, 49px...
（取决于内容块的高度）
```

**18px是目标值**，算法会尽量接近，但：
- 如果误差在±4px内 → 满意 ✓
- 如果误差超出 → 算法会尝试调整

---

### ❓ Q2：为什么有时候拆分了还是留白很大？

**A：** 拆分只对**单个`<p class="text-line">`元素**有效。

```
✅ 可以拆分的情况：
<p class="text-line">很长很长的文本...</p>
  → 拆分成多个<p>

❌ 不能拆分的情况：
<div class="item-description-wrapper">
  <p>第1行</p>
  <p>第2行</p>
  <p>第3行</p>
</div>
  → 这已经是3个独立的<p>，不会进一步拆分
```

---

### ❓ Q3：黄金分割搜索要运行多少次？

**A：** 15次迭代（第720行）

每次迭代调用2次 `calculateWithBuffer`，总共 **30次分页计算**。

但这是**离线计算**（在临时DOM上进行），不会影响用户体验。

---

### ❓ Q4：为什么打印时和预览时不一样？

**A：** 需要确保：
1. CSS的`@media print`规则正确
2. 页面边距设置一致
3. 浏览器打印设置中"页边距"设为"默认"或"无"

**检查项：**
```scss
@media print {
  @page {
    margin: 0;
    size: A4;
  }
}
```

---

## 🎓 进阶话题

### 如何调试分页算法？

打开浏览器控制台（F12），刷新页面，你会看到：

```
📊 初测结果 (safetyBuffer=0): 第1页=4.0px, 第2页=563.0px
🎯 使用固定留白策略（已禁用动态调整）
   第1页目标: 18px ± 4px（范围: 14-22px）
🔍 使用黄金分割搜索优化safetyBuffer...
   🔍 黄金分割迭代1/15: [-50.00, 50.00]...
   ...
✅ 选择方案: safetyBuffer=0.84px, 第1页留白=32.0px

==================== 详细分页过程 ====================
🔍 处理atom: text-line, 当前页已用980.5px
📏 文本行高度: 67.7px, 剩余空间: 66.5px
📝 文本行放不下，启动智能拆分
   📝 检测到文本行（87字符），开始按视觉行拆分...
      - 原始文本拆分为3个视觉行
   ✅ 成功拆分为3个视觉行
[1/3] 文本: "  •  主导开发系统级日志..."
    高度: 22.7px, 剩余: 66.5px
✓[1] 放入当前页（22.7px，剩余66.5px）
...
==================== 分页过程结束 ====================

🔧 应用行高压缩优化...
```

**如何解读：**
- 每一步都显示了高度、剩余空间
- 可以清楚地看到为什么元素被放到某一页
- 拆分过程会显示拆成了几行

---

## 📝 总结

**分页算法的核心思想：**

1. **测量驱动**：一切基于实际DOM测量，不依赖估算
2. **智能搜索**：用黄金分割快速找到最优safetyBuffer
3. **精细拆分**：对长文本按视觉行拆分，提高分页粒度
4. **动态优化**：根据实际情况压缩行高，减少浪费
5. **评分机制**：平衡第1页留白和整体页面利用率

**就像装箱子：**
- 先试装（粗测）
- 不断调整箱子大小（搜索）
- 把大件拆成小件（拆分）
- 压缩软的物品（行高压缩）
- 选择最优方案（评分）

---

**文档版本：** v1.0
**最后更新：** 2025-01-XX
**作者：** Claude Code
**代码位置：** `src/composables/usePagination.ts`
